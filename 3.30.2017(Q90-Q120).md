## Questions 91 ~ 120
##### Full score: 6 X 100 = 600
##### Actual score: 

### 91, Decode Ways
##### Questions: A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' to 1...
###### Idea: dfs + dp;
```
class Solution {
    vector<int> dp;
    int nDec(string &s, int i){
        if(i==s.size()) return 1;
        if(i==s.size()-1) return s[s.size()-1] !='0';
        if(dp[i]>=0) return dp[i];
        int x = int(s[i]-'0'), y = int(s[i+1]-'0');
        return dp[i] = int(x!=0)*(nDec(s,i+1) + int(x*10+y<=26)*nDec(s,i+2));
    }
public:
    int numDecodings(string s) {
        if(s.empty()) return 0;
        dp = vector<int>(s.size(),-1);
        return nDec(s,0);
    }
};
```

### 92, Reverse Linked List II
##### Questions: Reverse a linked list from position m to n. Do it in-place and in one-pass. For example:
```
Given 1->2->3->4->5->NULL, m = 2 and n = 4,
return 1->4->3->2->5->NULL.
```
###### Idea: One pass doing the job:
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        if(!head || !head->next || m==n) return head;
        ListNode preHead(0);
        preHead.next = head;
        auto p = &preHead;
        for(int i=1;i<m;++i) p = p->next;
        auto p1 = p->next, pt = p->next;
        auto p2 = p1->next;
        for(int i=m;i<n && p2;i++){
            auto tmp = p2->next;
            p2->next = p1;
            p1 = p2;
            p2 = tmp;
        }
        pt->next = p2;
        p->next = p1;
        return preHead.next;
    }
};
```


### 93, Restore IP Addresses
##### Questions: Given a string containing only digits, restore it by returning all possible valid IP address combinations. For example: Given `"25525511135"`, return `["255.255.11.135", "255.255.111.35"]`. (Order does not matter)
###### Idea: dfs (Need to care about the special case when `s[i]=='0'`)
```
typedef vector<int> vi;
class Solution {
    void help(vector<vi> &res,vi cur, string &s, int i, int k){
        if(k==4){
            if(i==s.size()) res.push_back(cur);
            return;
        }
        if(i==s.size()) return;
        if(s[i] == '0'){
            cur.push_back(0);
            help(res,cur,s,i+1,k+1);
            return;
        }
        for(int j=i+1;j<=s.size();j++){
            int m = stoi(s.substr(i,j-i));
            if(m>255) return;
            cur.push_back(m);
            help(res,cur,s,j,k+1);
            cur.pop_back();
        }
        return;
    }
public:
    vector<string> restoreIpAddresses(string s) {
        vector<vi> res;
        help(res,vi(),s,0,0);
        vector<string> ans;
        for(auto vec:res){
            s = to_string(vec[0]);
            s += "." + to_string(vec[1]) + "." + to_string(vec[2]) + "." + to_string(vec[3]);
            ans.push_back(s);
        }
        return ans;
    }
};
```


### 94, Binary Tree Inorder Traversal
##### Questions: Given a binary tree, return the inorder traversal of its nodes' values. (left -> root -> right)
###### Idea: using stack
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        
    }
};
```


### 95, Unique Binary Search Trees II
##### Questions: Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1...n. For example, Given n = 3, your program should return all 5 unique BST's shown below.
```
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```
###### Idea: using dfs
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        
    }
};
```


### 96, Unique Binary Search Trees
##### Questions: Given n, how many structurally unique BST's (binary search trees) that store values 1...n? For example, Given n = 3, your program should return all 5 unique BST's shown below.
```
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```
###### Idea: Using dfs (number of unique BST is only depends on the number of node n)
```
class Solution {
public:
    int numTrees(int n) {
        
    }
};
```


### 97, Interleaving String
##### Questions: Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. For example, Given: `s1 = "aabcc"`, `s2 = "dbbca"` When `s3 = "aadbbcbcac"`, return true. When `s3 = "aadbbbaccc"`, return false.
###### Idea: Using dp
```
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        
    }
};
```


### 98, Validate Binary Search Tree
##### Questions: Given a binary tree, determine if it is a valid binary search tree (BST).
###### Idea: Easy: just do it.
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        
    }
};
```

### 99, Recover Binary Search Tree
##### Questions: Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure.
###### Idea: 
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void recoverTree(TreeNode* root) {
        
    }
};
```



### 100, Same Tree
##### Questions: Given two binary trees, write a function to check if they are equal or not.
###### Idea: recursion is so easy
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        
    }
};
```



### 101, Decode Ways
##### Questions: 
###### Idea:
```
```



### 102, Decode Ways
##### Questions: 
###### Idea:
```
```



### 103, Decode Ways
##### Questions: 
###### Idea:
```
```


### 104, Decode Ways
##### Questions: 
###### Idea:
```
```

### 105, Decode Ways
##### Questions: 
###### Idea:
```
```

### 106, Decode Ways
##### Questions: 
###### Idea:
```
```


### 107, Decode Ways
##### Questions: 
###### Idea:
```
```


### 108, Decode Ways
##### Questions: 
###### Idea:
```
```


### 109, Decode Ways
##### Questions: 
###### Idea:
```
```

### 110, Decode Ways
##### Questions: 
###### Idea:
```
```

### 111, Decode Ways
##### Questions: 
###### Idea:
```
```

### 112, Decode Ways
##### Questions: 
###### Idea:
```
```

### 113, Decode Ways
##### Questions: 
###### Idea:
```
```

### 114, Decode Ways
##### Questions: 
###### Idea:
```
```

### 115, Decode Ways
##### Questions: 
###### Idea:
```
```


### 116, Decode Ways
##### Questions: 
###### Idea:
```
```


### 117, Decode Ways
##### Questions: 
###### Idea:
```
```


### 118, Decode Ways
##### Questions: 
###### Idea:
```
```

### 119, Decode Ways
##### Questions: 
###### Idea:
```
```

### 120, Decode Ways
##### Questions: 
###### Idea:
```
```










