## Questions 91 ~ 120
##### Full score: 6 X 100 = 600
##### Actual score: 120 + 

### 91, Decode Ways
##### Questions: A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' to 1...
###### Idea: dfs + dp;
```
class Solution {
    vector<int> dp;
    int nDec(string &s, int i){
        if(i==s.size()) return 1;
        if(i==s.size()-1) return s[s.size()-1] !='0';
        if(dp[i]>=0) return dp[i];
        int x = int(s[i]-'0'), y = int(s[i+1]-'0');
        return dp[i] = int(x!=0)*(nDec(s,i+1) + int(x*10+y<=26)*nDec(s,i+2));
    }
public:
    int numDecodings(string s) {
        if(s.empty()) return 0;
        dp = vector<int>(s.size(),-1);
        return nDec(s,0);
    }
};
```

### 92, Reverse Linked List II
##### Questions: Reverse a linked list from position m to n. Do it in-place and in one-pass. For example:
```
Given 1->2->3->4->5->NULL, m = 2 and n = 4,
return 1->4->3->2->5->NULL.
```
###### Idea: One pass doing the job:
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        if(!head || !head->next || m==n) return head;
        ListNode preHead(0);
        preHead.next = head;
        auto p = &preHead;
        for(int i=1;i<m;++i) p = p->next;
        auto p1 = p->next, pt = p->next;
        auto p2 = p1->next;
        for(int i=m;i<n && p2;i++){
            auto tmp = p2->next;
            p2->next = p1;
            p1 = p2;
            p2 = tmp;
        }
        pt->next = p2;
        p->next = p1;
        return preHead.next;
    }
};
```


### 93, Restore IP Addresses
##### Questions: Given a string containing only digits, restore it by returning all possible valid IP address combinations. For example: Given `"25525511135"`, return `["255.255.11.135", "255.255.111.35"]`. (Order does not matter)
###### Idea: dfs (Need to care about the special case when `s[i]=='0'`)
```
typedef vector<int> vi;
class Solution {
    void help(vector<vi> &res,vi cur, string &s, int i, int k){
        if(k==4){
            if(i==s.size()) res.push_back(cur);
            return;
        }
        if(i==s.size()) return;
        if(s[i] == '0'){
            cur.push_back(0);
            help(res,cur,s,i+1,k+1);
            return;
        }
        for(int j=i+1;j<=s.size();j++){
            int m = stoi(s.substr(i,j-i));
            if(m>255) return;
            cur.push_back(m);
            help(res,cur,s,j,k+1);
            cur.pop_back();
        }
        return;
    }
public:
    vector<string> restoreIpAddresses(string s) {
        vector<vi> res;
        help(res,vi(),s,0,0);
        vector<string> ans;
        for(auto vec:res){
            s = to_string(vec[0]);
            s += "." + to_string(vec[1]) + "." + to_string(vec[2]) + "." + to_string(vec[3]);
            ans.push_back(s);
        }
        return ans;
    }
};
```


### 94, Binary Tree Inorder Traversal
##### Questions: Given a binary tree, return the inorder traversal of its nodes' values. (left -> root -> right)
###### Idea: using stack  //Take care the forever loop
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode *> S;
        while(root || !S.empty()){
            while(root){
                S.push(root);
                root=root->left;
            }
            if(!S.empty()){
                ans.push_back(S.top()->val);
                root = S.top()->right;
                S.pop();
            }
        }
        return ans;
    }
};
```


### 95, Unique Binary Search Trees II
##### Questions: Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1...n. For example, Given n = 3, your program should return all 5 unique BST's shown below.
```
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```
###### Idea: using dfs  //Note that, every time if we need to add new tree into the set, we need to create a new root instead of the original one.
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
typedef vector<TreeNode*> vt;
class Solution {
public:
    vt Creat(int st,int ed){
        if(st>ed) return vt{NULL};
        vt rst;
        for(int i=st;i<=ed;i++){
            vt lvec = Creat(st,i-1),rvec = Creat(i+1,ed);
            for(TreeNode *l1:lvec) for(TreeNode *l2:rvec){
                TreeNode *root = new TreeNode(i);
                root->left = l1;
                root->right = l2;
                rst.push_back(root);
            }
        }
        return rst;
    }
    vector<TreeNode*> generateTrees(int n) {
        if(n==0) return vt();
        return Creat(1,n);
    }
};
```


### 96, Unique Binary Search Trees
##### Questions: Given n, how many structurally unique BST's (binary search trees) that store values 1...n? For example, Given n = 3, your program should return all 5 unique BST's shown below.
```
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```
###### Idea: Using dfs (number of unique BST is only depends on the number of node n) //Simple mathematical problem
```
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1,1);
        for(int k=2;k<=n;++k){
            dp[k] = 0;
            for(int j=1;j<=k;++j) dp[k] += dp[j-1]*dp[k-j];
        }
        return dp[n];
    }
};
```


### 97, Interleaving String
##### Questions: Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. For example, Given: `s1 = "aabcc"`, `s2 = "dbbca"` When `s3 = "aadbbcbcac"`, return true. When `s3 = "aadbbbaccc"`, return false.
###### Idea: Using dp  //`dp[i][j]` denote whether `s1.substr(0,i)` and `s2.substr(0,j)` are forming `s3.substr(0,i+j)`.
```
typedef vector<bool> vb;
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int n1 = s1.size(), n2 = s2.size(), n3 = s3.size();
        if(n3 != n1+n2) return false;
        map<char,int> cnt;
        for(auto c:s1) cnt[c]++;
        for(auto c:s2) cnt[c]++;
        for(auto c:s3){
            cnt[c]--;
            if(cnt[c]<0) return false;
        }
        cnt.clear();
        vector<vb> dp(n1+1,vb(n2+1,false));
        dp[0][0] = true;
        for(int i=1;i<=n1 && dp[i-1][0];++i) dp[i][0] = s1[i-1]==s3[i-1];
        for(int j=1;j<=n2 && dp[0][j-1];++j) dp[0][j] = s2[j-1]==s3[j-1];
        for(int i=1;i<=n1;++i) for(int j=1;j<=n2;++j){
            dp[i][j] = (dp[i-1][j]&&(s1[i-1]==s3[i+j-1]))||(dp[i][j-1]&&(s2[j-1]==s3[i+j-1]));
        }
        return dp[n1][n2];
    }
};
```


### 98, Validate Binary Search Tree
##### Questions: Given a binary tree, determine if it is a valid binary search tree (BST).
###### Idea: Easy: just do it.
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        long cur = (long)INT_MIN - 1;
        stack<TreeNode *> S;
        while(root || !S.empty()){
            while(root){
                S.push(root);
                root = root->left;
            }
            if(!S.empty()){
                if(S.top()->val <= cur) return false;
                cur = S.top()->val;
                root = S.top()->right;
                S.pop();
            }
        }
        return true;
    }
};
```

### 99, Recover Binary Search Tree
##### Questions: Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure.
###### Idea: Use inorder to extract the original order, then regain the original valus. //Be careful when regain the original order
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void recoverTree(TreeNode* root) {
        stack<TreeNode *> S;
        vector<TreeNode *> vec;
        vector<int> vals;
        while(root || !S.empty()){
            while(root){
                S.push(root);
                root = root->left;
            }
            if(!S.empty()){
                vec.push_back(S.top());
                vals.push_back(S.top()->val);
                root = S.top()->right;
                S.pop();
            }
        }
        sort(vals.begin(),vals.end());
        for(int i=0;i<vec.size();++i) vec[i]->val = vals[i];
        return;
    }
};
```



### 100, Same Tree
##### Questions: Given two binary trees, write a function to check if they are equal or not.
###### Idea: recursion is so easy
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p) return !q;
        if(!q) return false;
        if(p->val != q->val) return false;
        return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);
    }
};
```



### 101, Symmetric Tree
##### Questions: Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
###### Idea: Recursion
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        
    }
};
```



### 102, Binary Tree Level Order Traversal
##### Questions: Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).
###### Idea: recursion
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        
    }
};
```



### 103, Binary Tree Zigzag Level Order Traversal
##### Questions: Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).
###### Idea: The same as the previous one.
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        
    }
};
```


### 104, Maximum Depth of Binary Tree
##### Questions: Given a binary tree, find its maximum depth.
###### Idea: Recursion
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        
    }
};
```

### 105, Construct Binary Tree from Preorder and Inorder Traversal
##### Questions: Given preorder and inorder traversal of a tree, construct the binary tree.
###### Idea: Recursion //keep finding root and the range for each child tree
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        
    }
};
```

### 106, Construct Binary Tree from Inorder and Postorder Traversal
##### Questions: Given inorder and postorder traversal of a tree, construct the binary tree.
###### Idea: Recursion //keep finding root and the range for each child tree
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        
    }
};
```


### 107, Binary Tree Level Order Traversal II
##### Questions: Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).
###### Idea: The same as I
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        
    }
};
```


### 108, Convert Sorted Array to Binary Search Tree
##### Questions: Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
###### Idea: Keep finding root, and use recursion
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        
    }
};
```


### 109, Convert Sorted List to Binary Search Tree
##### Questions: Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
###### Idea: The same as the above one
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        
    }
};
```

### 110, Balanced Binary Tree
##### Questions: Given a binary tree, determine if it is height-balanced.
###### Idea: Recursion + dp
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        
    }
};
```

### 111, Decode Ways
##### Questions: 
###### Idea:
```
```

### 112, Decode Ways
##### Questions: 
###### Idea:
```
```

### 113, Decode Ways
##### Questions: 
###### Idea:
```
```

### 114, Decode Ways
##### Questions: 
###### Idea:
```
```

### 115, Decode Ways
##### Questions: 
###### Idea:
```
```


### 116, Decode Ways
##### Questions: 
###### Idea:
```
```


### 117, Decode Ways
##### Questions: 
###### Idea:
```
```


### 118, Decode Ways
##### Questions: 
###### Idea:
```
```

### 119, Decode Ways
##### Questions: 
###### Idea:
```
```

### 120, Decode Ways
##### Questions: 
###### Idea:
```
```










