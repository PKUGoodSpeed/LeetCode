## Questions 61 ~ 75
##### Full score: 3 X 100
##### Actual score: 78 + 
### 61,
##### Question: Given a list, rotate the list to the right by k places, where k is non-negative. For example:
##### Given `1->2->3->4->5->NULL` and `k = 2`,
##### return `4->5->1->2->3->NULL.`
###### Idea: Count and manipulate:
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head || !head->next) return head;
        int n = 1;
        for(auto p = head->next; p; p=p->next,++n);
        k %= n;
        if(!k) return head;
        auto p = head;
        for(int i=1;i<n-k;++i) p = p->next;
        auto p1 = p->next;
        p->next = NULL;
        p = p1;
        while(p1->next) p1=p1->next;
        p1->next = head;
        return p;
    }
};
```

### 62, Unique Paths
##### Question: A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?
###### Idea: Mathematics? dp?
###### Method #1: Mathematics:
```
class Solution {
public:
    int uniquePaths(int m, int n) {
        if(m<=1 || n <=1) return 1;
        if(n>m) swap(n,m);
        int N = m+n-2, M = n-1, ans = 1, i = 2;
        for(int j=0;j<M;++j){
            ans *= (N-j);
            while(i<=M && !(ans%i)) ans /= i++;
        }
        return ans;
    }
};
```
###### Method #2: DP:
```
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n,1);
        for(int i=1;i<m;++i) for(int j=1;j<n;++j) dp[j] += dp[j-1];
        return dp[n-1];
    }
};
```

### 63, Unique Paths II
##### Question: Follow up for "Unique Paths": Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. For example, There is one obstacle in the middle of a 3x3 grid as illustrated below.
```
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
```
##### The total number of unique paths is 2.
###### Idea: dp
```
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        if(obstacleGrid.empty() || obstacleGrid[0].empty()) return 1;
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        if(obstacleGrid[0][0] || obstacleGrid[m-1][n-1]) return 0;
        vector<int> dp(n,1);
        bool ok = false;
        for(int j=0;j<n;++j){
            if(obstacleGrid[0][j]) ok = true;
            if(ok) dp[j] = 0;
        }
        for(int i=1;i<m;++i){
            ok = true;
            for(int j=0;j<n;++j){
                if(!j) dp[j] *= 1-obstacleGrid[i][j];
                else dp[j] = (1-obstacleGrid[i][j])*(dp[j-1] + dp[j]);
                if(dp[j]) ok = false;
            }
            if(ok) return 0;
        }
        return dp[n-1];
    }
};
```

### 64, Minimum Path Sum
##### Question: Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
###### Idea: dp:
```
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.empty() || grid[0].empty()) return 0;
        int m = grid.size(), n = grid[0].size();
        vector<int> dp(n,grid[0][0]);
        for(int j=1;j<n;++j) dp[j] = dp[j-1] + grid[0][j];
        for(int i=1;i<m;++i) for(int j=0;j<n;++j){
            if(!j) dp[j] += grid[i][j];
            else dp[j] = grid[i][j] + min(dp[j],dp[j-1]);
        }
        return dp[n-1];
    }
};
```

### 65, Valid Number
##### Question: Validate if a given string is numeric.
###### Idea: state transformation:
###### Step 1, Creating state:
```
0: start
1: +
2: 9
3: .
4: .3
5: 3.
6: 3.4E
7: 3.4E-
8: 3.4E-2
9: end
```
###### Step 2, Possible transitions:
```
0: 0-9
1: .
2: +/-
3: e/E
4: Other
```
###### Step 3, Create Transition Table
```
class Solution {
    int state(char c){
        if(c>='0' && c<='9') return 0;
        if(c=='.') return 1;
        if(c=='-' || c=='+') return 2;
        if(c=='e' || c=='E') return 3;
        return 4;
    }
    int T[9][5]={{2, 3, 1, -1, -1},
                 {2, 3, -1, -1, -1},
                 {2, 5, -1, 6, 9},
                 {4, -1, -1, -1, -1},
                 {4, -1, -1, 6, 9},
                 {4, -1, -1, 6, 9},
                 {8, -1, 7, -1, -1},
                 {8, -1, -1, -1, -1},
                 {8, -1, -1, -1, 9}};
public:
    bool isNumber(string s) {
        auto i = s.find_first_not_of(" "), j = s.find_last_not_of(" ");
        if(i == string::npos) return false;
        s = s.substr(i,j-i+1);
        if(s.find_first_not_of("0123456789.eE+-") != string::npos) return false;
        int st = 0;
        for(auto c:s){
            st = T[st][state(c)];
            if(st == -1) return false;
        }
        return T[st][4]>=0;
    }
};
```









