# Questions 136 ~ 150


### 136. Single Number
##### Very easy, just use Xor operation:
```
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for(auto n:nums) ans^=n;
        return ans;
    }
};
```

### 137. Single Number II
##### Bit manipulation, pretty easy:
```
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for(int j=0;j<32;++j){
            int tmp = 0;
            for(auto n:nums) tmp += 1&(n>>j);
            if(tmp%3) ans += 1<<j;
        }
        return ans;
    }
};
```

### 138. Copy List with Random Pointer
##### First, merge the original list and the copied list, without fixing the random pointers of the copied nodes; Second, modify the random pointers of the copied nodes so that `A->random = A->pre->random->next`, which is a simple transformation; Third, separate the orignal and the copied lists.
```
/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
        if(!head) return NULL;
        for(auto p=head;p;){
            auto tmp = p->next;
            p->next = new RandomListNode(p->label);
            p->next->next = tmp;
            p = tmp;
        }
        for(auto p=head;p;p=p->next->next) if(p->random) p->next->random = p->random->next;
        auto ans = head->next;
        for(auto p=head,p1 = ans;p;){
            p->next = p1->next;
            p = p1->next;
            if(p){
                p1->next = p->next;
                p1 = p1->next;
            }
        }
        return ans;
    }
};
```

### 139. Word Break
##### Using ordinary dp, the coding is easier. Here I am using Tie + dp: first construct a Tie root, then with the help of dp to determine whether s is dividable. Since Tie is a little bit faster than hash map search, so this solution is 1ms faster than using the original dp.
```
class Solution {
    struct tie{
        bool isWord;
        map<char,tie*> next;
        tie():isWord(false){}
    };
    vector<int> dp;
    void insert(tie* root, string w){
        for(auto c:w){
            if(!root->next.count(c)) root->next[c] = new tie;
            root = root->next[c];
        }
        root->isWord = true;
    }
    tie * buildTie(vector<string> &wordDict){
        auto root = new tie;
        for(auto w:wordDict) insert(root,w);
        return root;
    }
    bool success(string &s,int i,tie *root){
        if(i>=(int)s.size()) return true;
        if(dp[i]>=0) return dp[i];
        auto p = root;
        for(int j=i;j<(int)s.size();++j){
            if(p->isWord && success(s,j,root)) return dp[i]=1;
            if(!p->next.count(s[j])) return dp[i] = 0;
            p = p->next[s[j]];
        }
        return dp[i] = p->isWord;
    }
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        int n = (int)s.size();
        dp = vector<int>(n,-1);
        auto root = buildTie(wordDict);
        return success(s,0,root);
    }
};
```

### 140. Word Break II
##### The idea is the same as #139
```
class Solution {
    unordered_map<int,vector<string> > dp;
    struct tie{
        bool isWord;
        map<char,tie*> next;
        tie():isWord(false){}
    };
    void insert(tie *root, string w){
        for(auto c:w){
            if(!root->next.count(c)) root->next[c] = new tie();
            root = root->next[c];
        }
        root->isWord = true;
    }
    tie *buildTie(vector<string> &wordDict){
        auto root = new tie();
        for(auto w:wordDict) insert(root,w);
        return root;
    }
    vector<string> buildAns(tie *root,string &s,int i){
        if(i>=(int)s.size()) return vector<string>{""};
        if(dp.count(i)) return dp[i];
        dp[i] = vector<string>();
        string tmp = "";
        auto p = root;
        for(int j=i;j<(int)s.size();++j){
            if(p->isWord){
                auto res = buildAns(root,s,j);
                for(auto w:res) dp[i].push_back(tmp + ' ' + w);
            }
            if(!p->next.count(s[j])) return dp[i];
            p = p->next[s[j]];
            tmp += s[j];
        }
        if(p->isWord) dp[i].push_back(tmp);
        return dp[i];
    }
public:
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        tie *root = buildTie(wordDict);
        return buildAns(root,s,0);
    }
};
```


### 141. Linked List Cycle
##### Using double pointer, easy checking:
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(!head || !head->next) return false;
        for(auto fast=head->next,slow=head;fast && fast->next;fast=fast->next->next,slow=slow->next) if(slow==fast) return true;
        return false;
    }
};
```

### 142. Linked List Cycle II
###### Step#1: using double pointers until two pointers merge; Step#2, let `fast = head`, reloop, for which `fast` moves one per step; until `fast` and `slow` merge again.
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if(!head || !head->next) return NULL;
        auto slow = head->next;
        bool ok = true;
        for(auto fast = slow->next;fast&&fast->next&&ok;slow=slow->next,fast=fast->next->next) if(slow==fast) {
            ok = false;
            break;
        }
        if(ok) return NULL;
        for(auto p=head;p!=slow;p=p->next,slow=slow->next);
        return slow;
    }
};
```

### 143. Reorder List
##### 1, Using double pointers to separate the original list; 2, Reverse the second one; 3 merger the two newly generated lists.
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    ListNode *reverseList(ListNode *head){
        if(!head || !head->next) return head;
        auto p1 = head, p2 = head->next;
        head->next = NULL;
        while(p1 && p2){
            auto tmp = p2->next;
            p2->next = p1;
            p1 = p2;
            p2 = tmp;
        }
        return p1;
    }
    ListNode *Merge(ListNode *l1,ListNode *l2){
        for(auto p=l1;p&&l2;){
            auto tmp1 = p->next, tmp2 = l2->next;
            p->next = l2;
            l2->next = tmp1;
            p = tmp1;
            l2 = tmp2;
        }
        return l1;
    }
public:
    void reorderList(ListNode* head) {
        if(!head || !head->next) return;
        auto slow = head, fast = head->next;
        while(fast && fast->next){
            slow=slow->next;
            fast = fast->next->next;
        }
        fast = reverseList(slow->next);
        slow->next = NULL;
        head = Merge(head,fast);
    }
};
```

### 144. Binary Tree Preorder Traversal
##### Using stack, very easy:
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
        vector<int> ans;
        while(root || !stk.empty()){
            while(root){
                ans.push_back(root->val);
                if(root->right) stk.push(root->right);
                root = root->left;
            }
            if(!stk.empty()){
                root = stk.top();
                stk.pop();
            }
        }
        return ans;
    }
};
```

### 145. Binary Tree Postorder Traversal
##### Preorder + reverse:
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode *> stk;
        while(root || !stk.empty()){
            while(root){
                ans.push_back(root->val);
                if(root->left) stk.push(root->left);
                root = root->right;
            }
            if(!stk.empty()){
                root = stk.top();
                stk.pop();
            }
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
};
```
