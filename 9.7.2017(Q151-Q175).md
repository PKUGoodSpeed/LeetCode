# Questions 151 ~ 175

### 151. Reverse Words in a String
##### Easily using stack
```
class Solution {
public:
    void reverseWords(string &s) {
        stack<string> stk;
        auto i = s.find_first_not_of(" ");
        while(i<s.size() && i!=string::npos){
            auto j = s.find_first_of(" ",i);
            if(j==string::npos) j = s.size();
            stk.push(s.substr(i,j-i));
            i = s.find_first_not_of(" ",j);
        }
        s.clear();
        while(!stk.empty()){
            if(!s.empty()) s+=' ';
            s += stk.top();
            stk.pop();
        }
        return;
    }
};
```

### 152. Maximum Product Subarray
##### My solution is finding subarrays that do not contain zeros, then manipulate each subarray separately. There seems to be other simple solutions.
```
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = (int)nums.size(),i = 0, ans = nums[0];
        while(i<n){
            while(i<n && nums[i]==0) ++i;
            if(i==n) break;
            int j = i, prod = 1;
            while(j<n && nums[j]!=0) prod*=nums[j++];
            if(j<n) ans = max(0,ans); 
            if(j==i+1 || prod>0) ans = max(ans,prod);
            else{
                int p = prod;
                for(int k=i;p<0;++k) p/=nums[k];
                ans = max(ans,p);
                p = prod;
                for(int k=j-1;p<0;--k) p/=nums[k];
                ans = max(ans,p);
            }
            i = j+1;
        }
        return ans;
    }
};
```

### 153. Find Minimum in Rotated Sorted Array
##### Easy bisection search
```
class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = (int)nums.size();
        if(nums[0]<=nums[n-1]) return nums[0];
        int i = 0, j = n;
        while(i<j-1){
            int c = (i+j)/2;
            if(nums[c]>nums[0]) i = c;
            else j = c;
        }
        return nums[j];
    }
};
```

### 154. Find Minimum in Rotated Sorted Array II
##### If there are duplicates, the complexity has to be O(n): like `[0,0,0,0,0...,0,-1,0,...0,0]`
```
class Solution {
public:
    int findMin(vector<int>& nums) {
        int ans = nums[0];
        for(auto n:nums) ans = min(ans,n);
        return ans;
    }
};
```

### 155. Min Stack
##### Using two stacks: one record the original data, one record the current minimum values.
```
class MinStack {
public:
    /** initialize your data structure here. */
    stack<int> minstk,stk;
    MinStack() {
    }
    
    void push(int x) {
        stk.push(x);
        if(minstk.empty() || minstk.top()>=x) minstk.push(x);
    }
    
    void pop() {
        if(stk.empty()) return;
        if(stk.top()==minstk.top()) minstk.pop();
        stk.pop();
    }
    
    int top() {
        return stk.top();
    }
    
    int getMin() {
        return minstk.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```
