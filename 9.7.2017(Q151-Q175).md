# Questions 151 ~ 175

### 151. Reverse Words in a String
##### Easily using stack
```
class Solution {
public:
    void reverseWords(string &s) {
        stack<string> stk;
        auto i = s.find_first_not_of(" ");
        while(i<s.size() && i!=string::npos){
            auto j = s.find_first_of(" ",i);
            if(j==string::npos) j = s.size();
            stk.push(s.substr(i,j-i));
            i = s.find_first_not_of(" ",j);
        }
        s.clear();
        while(!stk.empty()){
            if(!s.empty()) s+=' ';
            s += stk.top();
            stk.pop();
        }
        return;
    }
};
```

### 152. Maximum Product Subarray
##### My solution is finding subarrays that do not contain zeros, then manipulate each subarray separately. There seems to be other simple solutions.
```
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = (int)nums.size(),i = 0, ans = nums[0];
        while(i<n){
            while(i<n && nums[i]==0) ++i;
            if(i==n) break;
            int j = i, prod = 1;
            while(j<n && nums[j]!=0) prod*=nums[j++];
            if(j<n) ans = max(0,ans); 
            if(j==i+1 || prod>0) ans = max(ans,prod);
            else{
                int p = prod;
                for(int k=i;p<0;++k) p/=nums[k];
                ans = max(ans,p);
                p = prod;
                for(int k=j-1;p<0;--k) p/=nums[k];
                ans = max(ans,p);
            }
            i = j+1;
        }
        return ans;
    }
};
```

### 153. Find Minimum in Rotated Sorted Array
##### Easy bisection search
```
class Solution {
public:
    int findMin(vector<int>& nums) {
        int n = (int)nums.size();
        if(nums[0]<=nums[n-1]) return nums[0];
        int i = 0, j = n;
        while(i<j-1){
            int c = (i+j)/2;
            if(nums[c]>nums[0]) i = c;
            else j = c;
        }
        return nums[j];
    }
};
```

### 154. Find Minimum in Rotated Sorted Array II
##### If there are duplicates, the complexity has to be O(n): like `[0,0,0,0,0...,0,-1,0,...0,0]`
```
class Solution {
public:
    int findMin(vector<int>& nums) {
        int ans = nums[0];
        for(auto n:nums) ans = min(ans,n);
        return ans;
    }
};
```

### 155. Min Stack
##### Using two stacks: one record the original data, one record the current minimum values.
```
class MinStack {
public:
    /** initialize your data structure here. */
    stack<int> minstk,stk;
    MinStack() {
    }
    
    void push(int x) {
        stk.push(x);
        if(minstk.empty() || minstk.top()>=x) minstk.push(x);
    }
    
    void pop() {
        if(stk.empty()) return;
        if(stk.top()==minstk.top()) minstk.pop();
        stk.pop();
    }
    
    int top() {
        return stk.top();
    }
    
    int getMin() {
        return minstk.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

### 156. Binary Tree Upside Down
##### 1st, just using while loop, and keep using A,B and C to track the current root, left and right. It is not very hard:
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    inline bool isLeaf(TreeNode *root) { return root && !root->left && !root->right; }
public:
    TreeNode* upsideDownBinaryTree(TreeNode* root) {
        if(!root || !root->left) return root;
        TreeNode *A=root,*B=root->left,*C=root->right;
        A->left = NULL;
        A->right = NULL;
        while(B){
            TreeNode *tmpB = B->left, *tmpC = B->right;
            B->left = C;
            B->right = A;
            A = B;
            B = tmpB;
            C = tmpC;
        }
        return A;
    }
};
```
##### Using recursion: During recursion, we make sure we can always find `root->left`, that is why we change `root->left` and `root->right` at the last step.
```
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* upsideDownBinaryTree(TreeNode* root) {
        if(!root || !root->left) return root;
        TreeNode *new_tree = upsideDownBinaryTree(root->left);
        root->left->left = upsideDownBinaryTree(root->right);
        root->left->right = root;
        root->left = root->right = NULL;
        return new_tree;
    }
};
```

### 157. Read N Characters Given Read4
##### Beautiful solution: use `read4(buff+i)` to read:
```
// Forward declaration of the read4 API.
int read4(char *buf);

class Solution {
public:
    /**
     * @param buf Destination buffer
     * @param n   Maximum number of characters to read
     * @return    The number of characters read
     */
    int read(char *buf, int n) {
        /*char tmp[4];
        bool ok = true;
        for(int i=0;i<n;){
            int m = read4(tmp);
            for(int j=0;j<m && i+j<n; ++j) buf[i+j] = tmp[j];
            i+=m;
            if(i>=n || m<4) return min(i,n);
        }
        return n;*/
        int i=0,step=0;
        while(i<n && (step = read4(buf+i))) i+=step;
        if(i>=n) buf[n] = '\n';
        return min(i,n);
    }
};
```

### 158. Read N Characters Given Read4 II - Call multiple times
##### We need to use a reservior, here we use `queue` to store the left characters. At the beginning of every call, we first read data from the reservior, then from the file.
```
// Forward declaration of the read4 API.
int read4(char *buf);

class Solution {
    queue<char> res;
public:
    /**
     * @param buf Destination buffer
     * @param n   Maximum number of characters to read
     * @return    The number of characters read
     */
    int read(char *buf, int n) {
        int i = 0, step = 0;
        while(i<n && !res.empty()){
            buf[i++] = res.front();
            res.pop();
        }
        while(i<n && (step=read4(buf+i))) i+=step;
        if(i>n){
            for(int j=n;j<i;++j) res.push(buf[j]);
            buf[n] = '\n';
        }
        return min(i,n);
    }
};
```

### 159. Longest Substring with At Most Two Distinct Characters
##### Easy sliding window:
```
class Solution {
public:
    int lengthOfLongestSubstringTwoDistinct(string s) {
        int ans = 0,i=0,j=0,n=(int)s.size();
        map<char,int> cnt;
        while(i<n && j<n){
            while(i<n){
                cnt[s[i]]++;
                if((int)cnt.size()>2) break;
                ++i;
            }
            ans = max(ans,i-j);
            while(j<i && cnt.size()>2){
                cnt[s[j]]--;
                if(cnt[s[j]]==0) cnt.erase(s[j]);
                ++j;
            }
            i++;
        }
        return ans;
    }
};
```

### 160. Intersection of Two Linked Lists
##### Double pointers, loop until meets
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(!headA || !headB) return NULL;
        ListNode *l1=headA,*l2=headB;
        bool ok1= true, ok2=true;
        while(l1!=l2 && l1 && l2){
            l1=l1->next;
            l2=l2->next;
            if(!l1 && ok1){
                l1=headB;
                ok1 = false;
            }
            if(!l2 && ok2){
                l2 = headA;
                ok2 = false;
            }
        }
        return l1;
    }
};
```
##### Back track numbers:
```
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int nA = 0, nB = 0;
        ListNode *pA = headA,*pB = headB;
        while(pA){
            nA++;
            pA=pA->next;
        }
        while(pB){
            nB++;
            pB=pB->next;
        }
        if(nA<nB){
            swap(nA,nB);
            swap(headA,headB);
        }
        pA = headA;
        pB = headB;
        for(int i=0;i<nA-nB;i++,pA=pA->next);
        while(pA != pB){
            pA = pA->next;
            pB = pB->next;
        }
        return pA;
    }
};
```
